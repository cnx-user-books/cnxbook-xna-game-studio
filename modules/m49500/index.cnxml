<document xmlns="http://cnx.rice.edu/cnxml"> 
<title>Xna0112-Type Conversion, Casting, and Assignment Compatibility</title>
<metadata xmlns:md="http://cnx.rice.edu/mdml">
  <md:content-id>m49500</md:content-id>
  <md:title>Xna0112-Type Conversion, Casting, and Assignment Compatibility</md:title>
  <md:abstract>Learn about assignment compatibility, type conversion, and casting for both primitive and reference types. Also learn about the relationships among reference types, method invocations, and the location in the class hierarchy where a method is defined.</md:abstract>
  <md:uuid>a49424ef-1998-48e5-aa3b-60529571c1fc</md:uuid>
</metadata>

<content>






<para id="p1000">
Revised: Fri May 06 14:33:08 CDT 2016

</para>




<para id="p1001">
<emphasis id="em1000" effect="italics">
This page is part of a Book titled 


<link id="a1000" url="http://cnx.org/contents/GY804-eY">

XNA Game Studio 

</link>

.

</emphasis>
</para>












<section id="h11000">
<title>
<emphasis id="Table_of_Contents" effect="bold">

Table of Contents

</emphasis>


</title>






<list id="ul1000" list-type="bulleted">
<item id="li1000">
<link id="a1001" target-id="Table_of_Contents">

Table of Contents

</link>




</item>


<item id="li1001">
<link id="a1002" target-id="Preface">

Preface

</link>




<list id="ul1001" list-type="bulleted">
<item id="li1002">
<link id="a1003" target-id="Viewing_tip">

Viewing tip

</link>




<list id="ul1002" list-type="bulleted">
<item id="li1003">
<link id="a1004" target-id="Listings">

Listings

</link>




</item>


</list>


</item>


</list>


</item>


<item id="li1004">
<link id="a1005" target-id="General_background_information">

General 
	background information

</link>




<list id="ul1003" list-type="bulleted">
<item id="li1005">
<link id="a1006" target-id="Type_conversion">

Type conversion

</link>




</item>


<item id="li1006">
<link id="a1007" target-id="Assignment_compatibility">

Assignment compatibility

</link>




<list id="ul1004" list-type="bulleted">
<item id="li1007">
<link id="a1008" target-id="Successful_cast_depends_on_class_hierarchy">

Successful cast depends on class hierarchy

</link>




</item>


<item id="li1008">
<link id="a1009" target-id="The_generic_type_Object">

The generic type Object

</link>




</item>


</list>


</item>


<item id="li1009">
<link id="a1010" target-id="Calling_a_method_on_an_object">

Calling a method on an object

</link>




</item>


<item id="li1010">
<link id="a1011" target-id="Assignment_compatibility_and_type_conversion">

Assignment compatibility and type conversion

</link>




<list id="ul1005" list-type="bulleted">
<item id="li1011">
<link id="a1012" target-id="Type_conversion_and_the_cast_operator">

Type conversion and the cast operator

</link>




</item>


<item id="li1012">
<link id="a1013" target-id="Applying_a_cast_operator">

Applying a cast operator

</link>




</item>


<item id="li1013">
<link id="a1014" target-id="Primitive_values_and_type_conversion">

Primitive values and type conversion

</link>




<list id="ul1006" list-type="bulleted">
<item id="li1014">
<link id="a1015" target-id="Boolean_types">

Boolean types

</link>




</item>


<item id="li1015">
<link id="a1016" target-id="Numeric_primitive_types">

Numeric primitive types

</link>




</item>


</list>


</item>


<item id="li1016">
<link id="a1017" target-id="Assignment_compatibility_for_references">

Assignment compatibility for references

</link>




<list id="ul1007" list-type="bulleted">
<item id="li1017">
<link id="a1018" target-id="Type_Object_is_completely_generic">

Type Object is completely generic

</link>




</item>


<item id="li1018">
<link id="a1019" target-id="Converting_reference_types_with_a_cast">

Converting reference types with a cast

</link>




</item>


<item id="li1019">
<link id="a1020" target-id="Downcasting">

Downcasting

</link>




</item>


</list>


</item>


</list>


</item>


</list>


</item>


<item id="li1020">
<link id="a1021" target-id="Preview">

Preview

</link>




</item>


<item id="li1021">
<link id="a1022" target-id="Discussion_and_sample_code">

Discussion and sample code

</link>




<list id="ul1008" list-type="bulleted">
<item id="li1022">
<link id="a1023" target-id="The_class_named_A">

The class named A

</link>




</item>


<item id="li1023">
<link id="a1024" target-id="The_class_named_B">

The class named B

</link>




<list id="ul1009" list-type="bulleted">
<item id="li1024">
<link id="a1025" target-id="The_method_named_m">

The method named m

</link>




</item>


<item id="li1025">
<link id="a1026" target-id="The_class_named_C">

The class named C

</link>




</item>


</list>


</item>


<item id="li1026">
<link id="a1027" target-id="The_driver_class">

The driver class

</link>




<list id="ul1010" list-type="bulleted">
<item id="li1027">
<link id="a1028" target-id="An_object_of_the_class_named_B">

An object of the class named B

</link>




</item>


<item id="li1028">
<link id="a1029" target-id="Automatic_type_conversion">

Automatic type conversion

</link>




</item>


</list>


</item>


<item id="li1029">
<link id="a1030" target-id="Only_part_of_the_story_">

Only part of the story 

</link>




<list id="ul1011" list-type="bulleted">
<item id="li1030">
<link id="a1031" target-id="An_illegal_operation">

An illegal operation

</link>




</item>


<item id="li1031">
<link id="a1032" target-id="A_compiler_error">

A compiler error

</link>




</item>


</list>


</item>


<item id="li1032">
<link id="a1033" target-id="An_important_rule">

An important rule

</link>




<list id="ul1012" list-type="bulleted">
<item id="li1033">
<link id="a1034" target-id="This_case_violates_the_rule">

This case violates the rule

</link>




</item>


<item id="li1034">
<link id="a1035" target-id="The_solution_is_a_downcast">

The solution is a downcast

</link>




</item>


<item id="li1035">
<link id="a1036" target-id="Still_doesnt_solve_the_problem">

Still doesn't solve the problem

</link>




</item>


<item id="li1036">
<link id="a1037" target-id="What_is_the_problem_here">

What is the problem here?

</link>




</item>


<item id="li1037">
<link id="a1038" target-id="The_real_solution">

The real solution

</link>




</item>


</list>


</item>


<item id="li1038">
<link id="a1039" target-id="A_few_odds_and_ends">

A few odds and ends

</link>




<list id="ul1013" list-type="bulleted">
<item id="li1039">
<link id="a1040" target-id="A_legal_operation">

A legal operation

</link>




</item>


<item id="li1040">
<link id="a1041" target-id="Cannot_be_assigned_to_type_C">

Cannot be assigned to type C

</link>




</item>


<item id="li1041">
<link id="a1042" target-id="A_runtime_exception">

A runtime exception

</link>




</item>


<item id="li1042">
<link id="a1043" target-id="Another_failed_attempt">

Another failed attempt

</link>




</item>


<item id="li1043">
<link id="a1044" target-id="The_end_of_the_program">

The end of the program

</link>




</item>


</list>


</item>


</list>


</item>


<item id="li1044">
<link id="a1045" target-id="Run_the_program">

Run the program

</link>




</item>


<item id="li1045">
<link id="a1046" target-id="Run_my_program">

Run my program

</link>




</item>


<item id="li1046">
<link id="a1047" target-id="Summary">

Summary

</link>




</item>


<item id="li1047">
<link id="a1048" target-id="Miscellaneous">

Miscellaneous

</link>




</item>


<item id="li1048">
<link id="a1049" target-id="Complete_program_listing">

Complete program listing

</link>




</item>


</list>




	

</section>
<section id="h11001">
<title>
<emphasis id="Preface" effect="bold">

Preface

</emphasis>


</title>


	
	

<para id="p1002">
This module is one in a collection of modules designed primarily for 
	teaching 

<emphasis id="strong1000" effect="bold">
GAME 1343 Game and Simulation Programming I

</emphasis>
 at 
	Austin Community College in Austin, TX. These modules are intended to 
	supplement and not to replace the textbook.

</para>





<para id="p1003">
An earlier module titled 


<link id="a1050" url="http://cnx.org/contents/GY804-eY:g-5oRzQu">

Getting Started

</link>

 provided information on how 
to get started programming with Microsoft's XNA Game Studio.

</para>





<para id="p1004">
Object-oriented programs exhibit three main characteristics:

</para>





<list id="ul1014" list-type="bulleted">

	

<item id="li1049">
Encapsulation

</item>


	

<item id="li1050">
Inheritance

</item>


	

<item id="li1051">
Polymorphism

</item>




</list>




<para id="p1005">
I have explained encapsulation, inheritance, and compile-time polymorphism in 
earlier modules. Before I can explain runtime polymorphism, however, I need to 
step back and explain some concepts involving type conversion, casting, and 
assignment compatibility.

</para>




	

<section id="h21000">
<title>
<emphasis id="Viewing_tip" effect="bold">

Viewing tip

</emphasis>


</title>


	

<para id="p1006">
I recommend that you open another copy of this module in a separate 
browser window and use the following links to easily find and view the Listings while you are reading about them.

</para>



	

<section id="h31000">
<title>
<emphasis id="Listings" effect="bold">

Listings

</emphasis>


</title>


	

<list id="ul1015" list-type="bulleted">

		

<item id="li1052">
<link id="a1051" target-id="Listing_1">

Listing 1

</link>

. Source code for class A.

</item>


		

<item id="li1053">
<link id="a1052" target-id="Listing_2">

Listing 2

</link>

. Source code for class B.

</item>


		

<item id="li1054">
<link id="a1053" target-id="Listing_3">

Listing 3

</link>

. Source code for class C.

</item>


		

<item id="li1055">
<link id="a1054" target-id="Listing_4">

Listing 4

</link>

. Beginning of the class named Polymorph02.

</item>


		

<item id="li1056">
<link id="a1055" target-id="Listing_5">

Listing 5

</link>

. Try to call method m on variable var.

</item>


		

<item id="li1057">
<link id="a1056" target-id="Listing_6">

Listing 6

</link>

. Try a downcast to type A.

</item>


		

<item id="li1058">
<link id="a1057" target-id="Listing_7">

Listing 7

</link>

. Try a downcast to type B.

</item>


		

<item id="li1059">
<link id="a1058" target-id="Listing_8">

Listing 8

</link>

. Assign var to v1.

</item>


		

<item id="li1060">
<link id="a1059" target-id="Listing_9">

Listing 9

</link>

. Cannot be assigned to C.

</item>


		

<item id="li1061">
<link id="a1060" target-id="Listing_10">

Listing 10

</link>

. Another failed attempt.

</item>


		

<item id="li1062">
<link id="a1061" target-id="Listing_11">

Listing 11

</link>

. Project Polymorph02.

</item>


	

</list>


	

</section>
</section>
</section>
<section id="h11002">
<title>
<emphasis id="General_background_information" effect="bold">

General 
	background information

</emphasis>


</title>




<section id="h21001">
<title>
<emphasis id="Type_conversion" effect="bold">

Type conversion

</emphasis>


</title>




<para id="p1007">
This module explains type conversion for both primitive and reference types. 

</para>





</section>
<section id="h21002">
<title>
<emphasis id="Assignment_compatibility" effect="bold">

Assignment compatibility

</emphasis>


</title>




<para id="p1008">
A value of a particular type may be assignment-compatible with a variable of 
another type. If so, the value can be assigned directly to the variable.

</para>





<para id="p1009">
If not, it may be possible to perform a cast on the value to change its type 
and assign it to the variable as the new type.

</para>





<section id="h31001">
<title>
<emphasis id="Successful_cast_depends_on_class_hierarchy" effect="bold">

Successful cast depends on class hierarchy

</emphasis>


</title>




<para id="p1010">
With regard to reference types, whether or not a cast can be successfully 
performed depends on the relationship of the classes involved in the class 
hierarchy.

</para>





</section>
<section id="h31002">
<title>
<emphasis id="The_generic_type_Object" effect="bold">

The generic type Object

</emphasis>


</title>




<para id="p1011">
A reference to any object can be assigned to a reference variable of the type


<emphasis id="strong1001" effect="bold">
Object

</emphasis>
, because the 

<emphasis id="strong1002" effect="bold">
Object

</emphasis>
 class is a 
superclass of every other class.

</para>





<note id="note1000" type="">


In other words, an object instantiated from any class is 
assignment-compatible with the type 

<emphasis id="strong1003" effect="bold">
Object

</emphasis>
.

</note>






</section>
</section>
<section id="h21003">
<title>
<emphasis id="Calling_a_method_on_an_object" effect="bold">

Calling a method on an object

</emphasis>


</title>




<para id="p1012">
Whether or not a method can be called on a reference to an object depends on 
the 

<emphasis id="em1001" effect="italics">
current type

</emphasis>
 of the reference and the location in the class 
hierarchy where the method is defined.

</para>





<para id="p1013">
In order to use a reference of a class type to call a method, the method must 
be defined at or above that class in the class hierarchy.

</para>





</section>
<section id="h21004">
<title>
<emphasis id="Assignment_compatibility_and_type_conversion" effect="bold">

Assignment compatibility and type conversion

</emphasis>


</title>




<para id="p1014">
As background, for understanding runtime polymorphism, you need to understand


<emphasis id="em1002" effect="italics">
assignment compatibility

</emphasis>
 and 

<emphasis id="em1003" effect="italics">
type conversion

</emphasis>
.

</para>





<para id="p1015">
As I mentioned earlier, a value of a given type is assignment-compatible with 
another type if a value of the first type can be successfully assigned to a 
variable of the second type.

</para>





<section id="h31003">
<title>
<emphasis id="Type_conversion_and_the_cast_operator" effect="bold">

Type conversion and the cast operator

</emphasis>


</title>




<para id="p1016">
In some cases, type conversion happens automatically. In other cases, type 
conversion must be forced through the use of a cast operator.

</para>





<para id="p1017">
A cast operator is a unary operator, which has a single right operand. The 
physical representation of the cast operator is the name of a type enclosed by a 
pair of matching parentheses, as in:

</para>





<code id="pre1000" display="block">(int)</code>




</section>
<section id="h31004">
<title>
<emphasis id="Applying_a_cast_operator" effect="bold">

Applying a cast operator

</emphasis>


</title>




<para id="p1018">
Applying a cast operator to the name of a variable doesn't actually change 
the type of the variable. However, it does cause the contents of the variable to 
be treated as a different type for the evaluation of the expression in which the 
cast operator is contained.

</para>





</section>
<section id="h31005">
<title>
<emphasis id="Primitive_values_and_type_conversion" effect="bold">

Primitive values and type conversion

</emphasis>


</title>




<para id="p1019">
Assignment compatibility issues come into play for both primitive types and 
reference types.

</para>





<section id="h41000">
<title>
<emphasis id="Boolean_types" effect="bold">

Boolean types

</emphasis>


</title>




<para id="p1020">
To begin with, values of type 

<emphasis id="strong1004" effect="bold">
bool

</emphasis>
 can only be assigned to 
variables of type 

<emphasis id="strong1005" effect="bold">
bool

</emphasis>
 (you cannot change the type of a 

<emphasis id="strong1006" effect="bold">

bool

</emphasis>
). Thus, a value of type 

<emphasis id="strong1007" effect="bold">
bool

</emphasis>
 is not 
assignment-compatible with a variable of any other type.

</para>





</section>
<section id="h41001">
<title>
<emphasis id="Numeric_primitive_types" effect="bold">

Numeric primitive types

</emphasis>


</title>




<para id="p1021">
In general, numeric primitive values can be assigned to (are 
assignment-compatible with) a variable of a type whose numeric range is as wide 
as or wider than the range of the type of the value. In that case, the type of 
the value is automatically converted to the type of the variable.

</para>





<note id="note1001" type="">


For example, types 

<emphasis id="strong1008" effect="bold">
sbyte

</emphasis>
 and 

<emphasis id="strong1009" effect="bold">
short

</emphasis>
 can be 
assigned to a variable of type 

<emphasis id="strong1010" effect="bold">
int

</emphasis>
, because type 

<emphasis id="strong1011" effect="bold">
int

</emphasis>
 
has a wider range than either type 

<emphasis id="strong1012" effect="bold">
sbyte

</emphasis>
 or type 

<emphasis id="strong1013" effect="bold">
short

</emphasis>
.

</note>






<para id="p1022">
On the other hand, a primitive numeric value of a given type 

<emphasis id="strong1014" effect="bold">
cannot

</emphasis>
 be 
assigned to (is not assignment-compatible with) a variable of a type with a 
narrower range than the type of the value.

</para>





<para id="p1023">
However, it is possible to use a cast operator to force a type conversion for 
numeric primitive values.

</para>





<note id="note1002" type="">


Such a conversion will often result 
	in the loss of data, and that loss is the responsibility of the programmer 
	who performs the cast.

</note>






</section>
</section>
<section id="h31006">
<title>
<emphasis id="Assignment_compatibility_for_references" effect="bold">

Assignment compatibility for references

</emphasis>


</title>




<para id="p1024">
Assignment compatibility for references doesn't involve range issues, as is 
the case with primitives. Rather, the reference to an object instantiated from a 
given class can be assigned to (is assignment-compatible with):

</para>





<list id="ol1000" list-type="enumerated">

	

<item id="li1063">
Any reference variable whose type is the same as the class from which 
	the object was instantiated.

</item>


	

<item id="li1064">
Any reference variable whose type is a superclass of the class from 
	which the object was instantiated.

</item>


	

<item id="li1065">
Any reference variable whose type is an interface that is implemented by 
	the class from which the object was instantiated.

</item>


	

<item id="li1066">
Any reference variable whose type is an interface that is implemented by 
	a superclass of the class from which the object was instantiated.

</item>


	

<item id="li1067">
A couple of other cases involving interfaces that extend other 
	interfaces.

</item>




</list>




<para id="p1025">
In this module, we are interested only in cases 1 and 2 above. We will be 
interested in the other cases in future modules involving interfaces.

</para>





<para id="p1026">
Such an assignment does not require the use of a cast operator.

</para>





<section id="h41002">
<title>
<emphasis id="Type_Object_is_completely_generic" effect="bold">

Type Object is completely generic

</emphasis>


</title>




<para id="p1027">
As mentioned earlier, a reference to any object can be assigned to a reference variable of the type


<emphasis id="strong1015" effect="bold">
Object

</emphasis>
, because the 

<emphasis id="strong1016" effect="bold">
Object

</emphasis>
 class is a 
superclass of every other class.

</para>





</section>
<section id="h41003">
<title>
<emphasis id="Converting_reference_types_with_a_cast" effect="bold">

Converting reference types with a cast

</emphasis>


</title>




<para id="p1028">
Assignments of references, other than those listed above, require the use of 
a cast operator to purposely change the type of the reference.

</para>





<para id="p1029">
However, it is not possible to perform a successful cast to convert the type 
of a reference to another type in all cases.

</para>





<para id="p1030">
Generally, a cast can only be performed among reference types that fall on 
the same ancestral line of the class hierarchy, or on an ancestral line of an 
interface hierarchy. For example, a reference cannot be successfully cast to the 
type of a sibling or a cousin in the class hierarchy.

</para>





</section>
<section id="h41004">
<title>
<emphasis id="Downcasting" effect="bold">

Downcasting

</emphasis>


</title>




<para id="p1031">
When we cast a reference along the class hierarchy in a direction away from 
the 

<emphasis id="em1004" effect="italics">
root

</emphasis>
 class 

<emphasis id="strong1017" effect="bold">
Object

</emphasis>
 toward the 

<emphasis id="em1005" effect="italics">
leaves

</emphasis>
, we often refer to it 
as a 

<emphasis id="em1006" effect="italics">
downcast

</emphasis>
.

</para>





<para id="p1032">
While it is also possible to cast in the direction from the 

<emphasis id="em1007" effect="italics">
leaves

</emphasis>
 to the 


<emphasis id="em1008" effect="italics">
root

</emphasis>
, this conversion happens automatically, and the use of a cast operator is 
not required. 

</para>




	

</section>
</section>
</section>
</section>
<section id="h11003">
<title>
<emphasis id="Preview" effect="bold">

Preview

</emphasis>


</title>


	

<para id="p1033">
A sample program is provided that illustrates much of the detail involved 
	in type conversion, method invocation, and casting with respect to reference 
	types. 

</para>




	
	

</section>
<section id="h11004">
<title>
<emphasis id="Discussion_and_sample_code" effect="bold">

Discussion and sample code

</emphasis>


</title>


	


<para id="p1034">
The program named 

<emphasis id="strong1018" effect="bold">
Polymorph02

</emphasis>
, shown in 

<link id="a1062" target-id="Listing_11">

Listing 11

</link>

 near the 
end of the module illustrates the use of the cast operator with references.

</para>





<para id="p1035">
When you examine that program, you will see that two classes named 

<emphasis id="strong1019" effect="bold">
A

</emphasis>
 
and 

<emphasis id="strong1020" effect="bold">
C

</emphasis>
 each extend the class named 

<emphasis id="strong1021" effect="bold">
Object

</emphasis>
. 
Hence, we might say that they are siblings in the class hierarchy.

</para>





<para id="p1036">
Another class named 

<emphasis id="strong1022" effect="bold">
B

</emphasis>
 extends the class named 

<emphasis id="strong1023" effect="bold">
A

</emphasis>
. 
Thus, we might say that 

<emphasis id="strong1024" effect="bold">
A

</emphasis>
 is a child of 

<emphasis id="strong1025" effect="bold">
Object

</emphasis>
, 
and 

<emphasis id="strong1026" effect="bold">
B

</emphasis>
 is a child of 

<emphasis id="strong1027" effect="bold">
A

</emphasis>
.

</para>





<section id="h21005">
<title>
<emphasis id="The_class_named_A" effect="bold">

The class named A

</emphasis>


</title>




<para id="p1037">
The definition of the class named 

<emphasis id="strong1028" effect="bold">
A

</emphasis>
 is shown in 

<link id="a1063" target-id="Listing_1">

Listing 1

</link>

. 
This class implicitly extends the class named 

<emphasis id="strong1029" effect="bold">
Object

</emphasis>
 by 
default. 

</para>



	


<note id="note1003" type="">


<para id="p1038">
<emphasis id="Listing_1" effect="bold">

Listing 1

</emphasis>

. Source code for class A.

</para>



				

<code id="pre1001" display="block">using System;

class A {
  //this class is empty
}//end class A
</code>



				

</note>

			


		



	




	

<para id="p1039">
The class named 

<emphasis id="strong1030" effect="bold">
A

</emphasis>
 is empty. It was included in this 
	example for the sole purpose of adding a layer of inheritance to the class 
	hierarchy.

</para>





</section>
<section id="h21006">
<title>
<emphasis id="The_class_named_B" effect="bold">

The class named B

</emphasis>


</title>




<para id="p1040">
<link id="a1064" target-id="Listing_2">

Listing 2

</link>

 shows the definition of the class named 

<emphasis id="strong1031" effect="bold">
B

</emphasis>
. This 
class extends the class named 

<emphasis id="strong1032" effect="bold">
A

</emphasis>
 as indicated by the colon that joins the 


<emphasis id="strong1033" effect="bold">
B

</emphasis>
 and the 

<emphasis id="strong1034" effect="bold">
A

</emphasis>
 on the first line. 

</para>





<note id="note1004" type="">


<para id="p1041">
<emphasis id="Listing_2" effect="bold">

Listing 2

</emphasis>

. Source code for class B.

</para>



				

<code id="pre1002" display="block">class B : A {
  public void m() {
    Console.WriteLine("m in class B");
  }//end method m()
}//end class B
</code>



				

</note>

			


		



	




	

<section id="h31007">
<title>
<emphasis id="The_method_named_m" effect="bold">

The method named m

</emphasis>


</title>




<para id="p1042">
The class named 

<emphasis id="strong1035" effect="bold">
B

</emphasis>
 defines a method named 

<emphasis id="strong1036" effect="bold">
m

</emphasis>
. 
The behavior of the method is simply to display a message each time it is 
called.

</para>





</section>
<section id="h31008">
<title>
<emphasis id="The_class_named_C" effect="bold">

The class named C

</emphasis>


</title>




<para id="p1043">
<link id="a1065" target-id="Listing_3">

Listing 3

</link>

 shows the definition of the class named 

<emphasis id="strong1037" effect="bold">
C

</emphasis>
, which 
also extends 

<emphasis id="strong1038" effect="bold">
Object

</emphasis>
 by default. 

</para>





<note id="note1005" type="">


<para id="p1044">
<emphasis id="Listing_3" effect="bold">

Listing 3

</emphasis>

. Source code for class C.

</para>



				

<code id="pre1003" display="block">class C {
  //this class is empty
}//end class C
</code>



				

</note>

			


		



	




	

<para id="p1045">
The class named 

<emphasis id="strong1039" effect="bold">
C

</emphasis>
 is also empty. It was included in this 
	example as a sibling class for the class named 

<emphasis id="strong1040" effect="bold">
A

</emphasis>
. Stated 
	differently, it was included as a class that is not in the ancestral line of 
	the class named 

<emphasis id="strong1041" effect="bold">
B

</emphasis>
.

</para>





</section>
</section>
<section id="h21007">
<title>
<emphasis id="The_driver_class" effect="bold">

The driver class

</emphasis>


</title>




<para id="p1046">
<link id="a1066" target-id="Listing_4">

Listing 4

</link>

 shows the beginning of the driver class named 

<emphasis id="strong1042" effect="bold">
Polymorph02

</emphasis>
, 
which also extends 

<emphasis id="strong1043" effect="bold">
Object

</emphasis>
 by default.


</para>





<note id="note1006" type="">


<para id="p1047">
<emphasis id="Listing_4" effect="bold">

Listing 4

</emphasis>

. Beginning of the class named Polymorph02.

</para>



				

<code id="pre1004" display="block">public class Polymorph02 {
  public static void Main() {
    Object var = new B();
</code>



				

</note>

			


		



	




	

<section id="h31009">
<title>
<emphasis id="An_object_of_the_class_named_B" effect="bold">

An object of the class named B

</emphasis>


</title>




<para id="p1048">
This code instantiates an object of the class 

<emphasis id="strong1044" effect="bold">
B

</emphasis>
 and assigns 
the object's reference to a reference variable of type 

<emphasis id="strong1045" effect="bold">
Object

</emphasis>
.

</para>





<note id="note1007" type="">


Let me repeat what I just said for emphasis. The reference to the object of 
type 

<emphasis id="strong1046" effect="bold">
B

</emphasis>
 was not assigned to a reference variable of type 

<emphasis id="strong1047" effect="bold">

B

</emphasis>
. Instead, it was assigned to a reference variable of type 

<emphasis id="strong1048" effect="bold">

Object

</emphasis>
.

</note>






<para id="p1049">
This assignment is allowable because 

<emphasis id="strong1049" effect="bold">
Object

</emphasis>
 is a superclass 
of 

<emphasis id="strong1050" effect="bold">
B

</emphasis>
. In other words, the reference to the object of the class


<emphasis id="strong1051" effect="bold">
B

</emphasis>
 is 

<emphasis id="em1009" effect="italics">
assignment-compatible

</emphasis>
 with a reference variable 
of the type 

<emphasis id="strong1052" effect="bold">
Object

</emphasis>
.

</para>





</section>
<section id="h31010">
<title>
<emphasis id="Automatic_type_conversion" effect="bold">

Automatic type conversion

</emphasis>


</title>




<para id="p1050">
In this case, the reference of type 

<emphasis id="strong1053" effect="bold">
B

</emphasis>
 is automatically 
converted to type 

<emphasis id="strong1054" effect="bold">
Object

</emphasis>
 and assigned to the reference variable 
of type 

<emphasis id="strong1055" effect="bold">
Object

</emphasis>
.

</para>





<note id="note1008" type="">


Note that the use of a cast 
	operator was not required in this assignment.

</note>






</section>
</section>
<section id="h21008">
<title>
<emphasis id="Only_part_of_the_story_" effect="bold">

Only part of the story 

</emphasis>


</title>




<para id="p1051">
However, assignment compatibility is only part of the story. The simple fact 
that a reference is assignment-compatible with a reference variable of a given 
type says nothing about what can be done with the reference after it is assigned 
to the reference variable.

</para>





<section id="h31011">
<title>
<emphasis id="An_illegal_operation" effect="bold">

An illegal operation

</emphasis>


</title>




<para id="p1052">
For example, in this case, the reference variable that was automatically 
converted to type 

<emphasis id="strong1056" effect="bold">
Object

</emphasis>
 cannot be used directly to call the 
method named 

<emphasis id="strong1057" effect="bold">
m

</emphasis>
 on the object of type B. This 
is indicated in 

<link id="a1067" target-id="Listing_5">

Listing 5

</link>

. 

</para>





<note id="note1009" type="">


<para id="p1053">
<emphasis id="Listing_5" effect="bold">

Listing 5

</emphasis>

. Try to call method m on variable var.

</para>



				

<code id="pre1005" display="block">    //Following will not compile
    //var.m();
</code>



				

</note>

			


		



	




	

</section>
<section id="h31012">
<title>
<emphasis id="A_compiler_error" effect="bold">

A compiler error

</emphasis>


</title>




<para id="p1054">
An attempt to call the method named 

<emphasis id="strong1058" effect="bold">
m

</emphasis>
 on the reference 
variable of type 

<emphasis id="strong1059" effect="bold">
Object

</emphasis>
 in 

<link id="a1068" target-id="Listing_5">

Listing 5

</link>

 resulted in the following 
compiler error:

</para>





<code id="pre1006" display="block">error CS0117:
'object' does not contain a definition for 'm'</code>




<para id="p1055">
It was necessary to convert the statement to a comment in order to cause the 
program to compile successfully.

</para>





</section>
</section>
<section id="h21009">
<title>
<emphasis id="An_important_rule" effect="bold">

An important rule

</emphasis>


</title>




<para id="p1056">
In order to use a reference of a class type to call a method, the method must 
be defined at or above that class in the class hierarchy. Stated differently, 
the method must either be defined in, or inherited into that class. 

</para>





<section id="h31013">
<title>
<emphasis id="This_case_violates_the_rule" effect="bold">

This case violates the rule

</emphasis>


</title>




<para id="p1057">
In this case, the method named 

<emphasis id="strong1060" effect="bold">
m

</emphasis>
 is defined in the class 
named 

<emphasis id="strong1061" effect="bold">
B

</emphasis>
, which is two levels down from the class named 

<emphasis id="strong1062" effect="bold">

Object

</emphasis>
.

</para>





<note id="note1010" type="">


The method named 

<emphasis id="strong1063" effect="bold">
m

</emphasis>
 is neither defined in nor inherited into 
the class named 

<emphasis id="strong1064" effect="bold">
Object

</emphasis>
.

</note>






<para id="p1058">
When the reference to the object of the class 

<emphasis id="strong1065" effect="bold">
B

</emphasis>
 was assigned 
to the reference variable of type 

<emphasis id="strong1066" effect="bold">
Object

</emphasis>
, the type of the 
reference was automatically converted to type 

<emphasis id="strong1067" effect="bold">
Object

</emphasis>
.

</para>





<para id="p1059">
Therefore, because the reference is type 

<emphasis id="strong1068" effect="bold">
Object

</emphasis>
, it cannot 
be used directly to call the method named 

<emphasis id="strong1069" effect="bold">
m

</emphasis>
.

</para>





</section>
<section id="h31014">
<title>
<emphasis id="The_solution_is_a_downcast" effect="bold">

The solution is a downcast

</emphasis>


</title>




<para id="p1060">
In this case, the solution to the problem is a downcast.

</para>





<para id="p1061">
The code in 

<link id="a1069" target-id="Listing_6">

Listing 6

</link>

 shows an attempt to solve the problem by casting the 
reference down the hierarchy to type 

<emphasis id="strong1070" effect="bold">
A

</emphasis>
. 

</para>





<note id="note1011" type="">


<para id="p1062">
<emphasis id="Listing_6" effect="bold">

Listing 6

</emphasis>

. Try a downcast to type A.

</para>



				

<code id="pre1007" display="block">    //Following will not compile
    //((A)var).m();   
</code>



				

</note>

			


		



	




	

</section>
<section id="h31015">
<title>
<emphasis id="Still_doesnt_solve_the_problem" effect="bold">

Still doesn't solve the problem

</emphasis>


</title>




<para id="p1063">
However, this still doesn't solve the problem, and the result is another 
compiler error.

</para>





<note id="note1012" type="">


The method named 

<emphasis id="strong1071" effect="bold">
m

</emphasis>
 is neither defined in nor inherited into 
the class named 

<emphasis id="strong1072" effect="bold">
A

</emphasis>
.

</note>






<para id="p1064">
Again, it was necessary to convert the statement into a comment in order to 
cause the program to compile.

</para>





</section>
<section id="h31016">
<title>
<emphasis id="What_is_the_problem_here" effect="bold">

What is the problem here?

</emphasis>


</title>




<para id="p1065">
The problem with this approach is that the downcast simply didn't go far enough down the 
inheritance hierarchy.

</para>





<para id="p1066">
The class named 

<emphasis id="strong1073" effect="bold">
A

</emphasis>
 does not contain a definition of the 
method named 

<emphasis id="strong1074" effect="bold">
m

</emphasis>
. Neither does it inherit the method named


<emphasis id="strong1075" effect="bold">
m

</emphasis>
. The method named 

<emphasis id="strong1076" effect="bold">
m

</emphasis>
 is defined in class


<emphasis id="strong1077" effect="bold">
B,

</emphasis>
 which is a subclass of 

<emphasis id="strong1078" effect="bold">
A

</emphasis>
.

</para>





<para id="p1067">
Therefore, a reference of type 

<emphasis id="strong1079" effect="bold">
A

</emphasis>
 is no more useful than a 
reference of type 

<emphasis id="strong1080" effect="bold">
Object

</emphasis>
 insofar as calling the method named


<emphasis id="strong1081" effect="bold">
m

</emphasis>
 is concerned.

</para>





</section>
<section id="h31017">
<title>
<emphasis id="The_real_solution" effect="bold">

The real solution

</emphasis>


</title>




<para id="p1068">
The solution to the problem is shown in 

<link id="a1070" target-id="Listing_7">

Listing 7

</link>

. 

</para>





<note id="note1013" type="">


<para id="p1069">
<emphasis id="Listing_7" effect="bold">

Listing 7

</emphasis>

. Try a downcast to type B.

</para>



				

<code id="pre1008" display="block">    //Following will compile and run
    ((B)var).m();
</code>



				

</note>

			


		



	




	

<para id="p1070">
The code in 

<link id="a1071" target-id="Listing_7">

Listing 7

</link>

 casts (temporarily converts) the reference value contained in 
	the 

<emphasis id="strong1082" effect="bold">
Object

</emphasis>
 variable named 

<emphasis id="strong1083" effect="bold">
var

</emphasis>
 to type
	

<emphasis id="strong1084" effect="bold">
B

</emphasis>
.

</para>





<para id="p1071">
The method named 

<emphasis id="strong1085" effect="bold">
m

</emphasis>
 is defined in the class named 

<emphasis id="strong1086" effect="bold">
B

</emphasis>
. 
Therefore, a reference of type 

<emphasis id="strong1087" effect="bold">
B

</emphasis>
 can be used to call the 
method.

</para>





<para id="p1072">
The code in 

<link id="a1072" target-id="Listing_7">

Listing 7

</link>

 compiles and executes successfully. This causes the 
method named 

<emphasis id="strong1088" effect="bold">
m

</emphasis>
 to execute, producing the following output on 
the computer screen:

</para>





<code id="pre1009" display="block"> m in class B</code>




</section>
</section>
<section id="h21010">
<title>
<emphasis id="A_few_odds_and_ends" effect="bold">

A few odds and ends

</emphasis>


</title>




<para id="p1073">
Before leaving this topic, let's look at a few more issues.

</para>





<para id="p1074">
The code in 

<link id="a1073" target-id="Listing_8">

Listing 8

</link>

 declares and populates a new variable of type 

<emphasis id="strong1089" effect="bold">

B.

</emphasis>
 

</para>





<note id="note1014" type="">


<para id="p1075">
<emphasis id="Listing_8" effect="bold">

Listing 8

</emphasis>

. Assign var to v1.

</para>



				

<code id="pre1010" display="block">    //Following will compile and run
    B v1 = (B)var;
</code>



				

</note>

			


		



	




	

<para id="p1076">
The code in 

<link id="a1074" target-id="Listing_8">

Listing 8

</link>

 uses a cast to:

</para>





<list id="ul1016" list-type="bulleted">

	

<item id="li1068">
Convert the contents of the 

<emphasis id="strong1090" effect="bold">
Object

</emphasis>
 variable to type
	

<emphasis id="strong1091" effect="bold">
B

</emphasis>
</item>


	

<item id="li1069">
Assign the converted reference to the new reference variable of type
	

<emphasis id="strong1092" effect="bold">
B

</emphasis>
.

</item>




</list>




<section id="h31018">
<title>
<emphasis id="A_legal_operation" effect="bold">

A legal operation

</emphasis>


</title>




<para id="p1077">
This is a legal operation. In this class hierarchy, the reference to the 
object of the class 

<emphasis id="strong1093" effect="bold">
B

</emphasis>
 can be assigned to a reference variable 
of the types 

<emphasis id="strong1094" effect="bold">
B,

</emphasis>
 

<emphasis id="strong1095" effect="bold">
A

</emphasis>
, or 

<emphasis id="strong1096" effect="bold">
Object

</emphasis>
.

</para>





<note id="note1015" type="">


While this operation is legal, it is usually not a good idea to have two 
different reference variables that contain references to the same object. In 
this case, the variables named 

<emphasis id="strong1097" effect="bold">
var

</emphasis>
 and 

<emphasis id="strong1098" effect="bold">
v1

</emphasis>
 both 
	contain a reference to the same object.

</note>






</section>
<section id="h31019">
<title>
<emphasis id="Cannot_be_assigned_to_type_C" effect="bold">

Cannot be assigned to type C

</emphasis>


</title>




<para id="p1078">
However, the reference to the object of the class 

<emphasis id="strong1099" effect="bold">
B

</emphasis>
 cannot 
be assigned to a reference variable of any other type, including type 

<emphasis id="strong1100" effect="bold">
C

</emphasis>
. 
An attempt to do so is shown in 

<link id="a1075" target-id="Listing_9">

Listing 9

</link>

. 

</para>





<note id="note1016" type="">


<para id="p1079">
<emphasis id="Listing_9" effect="bold">

Listing 9

</emphasis>

. Cannot be assigned to C.

</para>



				

<code id="pre1011" display="block">    //Following will not execute.
    // Causes a runtime exception.
    //C v2 = (C)var;
</code>



				

</note>

			


		



	




	

<para id="p1080">
The code in 

<link id="a1076" target-id="Listing_9">

Listing 9

</link>

 attempts to cast the reference to type 

<emphasis id="strong1101" effect="bold">
C

</emphasis>
 
	and assign it to a reference variable of type 

<emphasis id="strong1102" effect="bold">
C

</emphasis>
.

</para>





</section>
<section id="h31020">
<title>
<emphasis id="A_runtime_exception" effect="bold">

A runtime exception

</emphasis>


</title>




<para id="p1081">
Although the program will compile, it won't execute. An attempt to execute 
the statement in 

<link id="a1077" target-id="Listing_9">

Listing 9

</link>

 results in an exception at runtime.

</para>





<para id="p1082">
As a result, it was necessary to convert the statement into a comment in 
order to execute the program.

</para>





</section>
<section id="h31021">
<title>
<emphasis id="Another_failed_attempt" effect="bold">

Another failed attempt

</emphasis>


</title>




<para id="p1083">
Similarly, an attempt to cast the reference to type 

<emphasis id="strong1103" effect="bold">
B

</emphasis>
 and 
assign it to a reference variable of type 

<emphasis id="strong1104" effect="bold">
C

</emphasis>
, as shown in 


<link id="a1078" target-id="Listing_10">

Listing 10

</link>

, won't compile. 

</para>





<note id="note1017" type="">


<para id="p1084">
<emphasis id="Listing_10" effect="bold">

Listing 10

</emphasis>

. Another failed attempt.

</para>



				

<code id="pre1012" display="block">    //Following will not compile
    //C v3 = (B)var;

    //Pause until user presses any key.
    Console.ReadKey();
  }//end Main
}//end class Polymorph02
</code>



				

</note>

			


		



	




	

<para id="p1085">
The problem here is that the class 

<emphasis id="strong1105" effect="bold">
C

</emphasis>
 is not a superclass 
	of the class named 

<emphasis id="strong1106" effect="bold">
B

</emphasis>
. Therefore, a reference of type
	

<emphasis id="strong1107" effect="bold">
B

</emphasis>
 is not assignment-compatible with a reference variable of 
	type 

<emphasis id="strong1108" effect="bold">
C

</emphasis>
.

</para>





<para id="p1086">
Again, it was necessary to convert the statement to a comment in order to 
compile the program. 

</para>





</section>
<section id="h31022">
<title>
<emphasis id="The_end_of_the_program" effect="bold">

The end of the program

</emphasis>


</title>




<para id="p1087">
<link id="a1079" target-id="Listing_10">

Listing 10

</link>

 signals the end of the 

<emphasis id="strong1109" effect="bold">
Main

</emphasis>
 method, the end of 
the class, and the end of the program.

</para>







</section>
</section>
</section>
<section id="h11005">
<title>
<emphasis id="Run_the_program" effect="bold">

Run the program

</emphasis>


</title>





<para id="p1088">
I encourage you to copy the code from 

<link id="a1080" target-id="Listing_11">

Listing 11

</link>

. Use that code to create a 
C# console project. Compile and run the project. Experiment with the code, 
making changes, and observing the results of your changes. Make certain that 
you can explain why your changes behave as they do. 

</para>





</section>
<section id="h11006">
<title>
<emphasis id="Run_my_program" effect="bold">

Run my program

</emphasis>


</title>




<para id="p1089">
Click 

<link id="a1081" url="Polymoeph02.zip">

here

</link>

 to download a zip file containing my 
version of the program. Extract the folder named 

<emphasis id="strong1110" effect="bold">
Polymoeph02

</emphasis>
 from the 
zip file and save it somewhere on your disk. Start 

<emphasis id="strong1111" effect="bold">
Visual C# 2010 
Express

</emphasis>
 and select 

<emphasis id="strong1112" effect="bold">
Open Project...

</emphasis>
 from the 

<emphasis id="strong1113" effect="bold">

File

</emphasis>
 menu. Navigate to the project folder and select the file with the 
extension of 

<emphasis id="strong1114" effect="bold">
.sln

</emphasis>
. This should cause the project to open and be 
ready to run or debug as described in the earlier module titled 


<link id="a1082" url="http://cnx.org/contents/GY804-eY:g-5oRzQu">

Getting Started

</link>

.

</para>



	

</section>
<section id="h11007">
<title>
<emphasis id="Summary" effect="bold">

Summary

</emphasis>


</title>




<para id="p1090">
This module discusses type conversion for primitive and reference types.

</para>





<para id="p1091">
A value of a particular type may be assignment-compatible with variables of 
other types.

</para>





<para id="p1092">
If the type of a value is not assignment-compatible with a variable of a 
given type, it may be possible to perform a cast on the value to change its type 
and assign it to the variable as the new type. For primitive types, this will 
often result in the loss of information.

</para>





<para id="p1093">
In general, numeric values of primitive types can be assigned to any variable 
whose type represents a numeric range that is as wide as or wider than the range 
of the value's type. (Values of type 

<emphasis id="strong1115" effect="bold">
bool

</emphasis>
 can only be assigned 
to variables of type 

<emphasis id="strong1116" effect="bold">
bool

</emphasis>
.)

</para>





<para id="p1094">
With respect to reference types, the reference to an object instantiated from 
a given class can be assigned to any of the following without the use of a cast:

</para>





<list id="ul1017" list-type="bulleted">

	

<item id="li1070">
Any reference variable whose type is the same as the class from which 
	the object was instantiated.

</item>


	

<item id="li1071">
Any reference variable whose type is a superclass of the class from 
	which the object was instantiated.

</item>


	

<item id="li1072">
Any reference variable whose type is an interface that is implemented by 
	the class from which the object was instantiated.

</item>


	

<item id="li1073">
Any reference variable whose type is an interface that is implemented by 
	a superclass of the class from which the object was instantiated.

</item>


	

<item id="li1074">
A couple of other cases involving interfaces that extend other 
	interfaces.

</item>




</list>




<para id="p1095">
Assignments of references, other than those listed above, require the use of 
a cast to change the type of the reference.

</para>





<para id="p1096">
It is not always possible to perform a successful cast to convert the type of 
a reference. Whether or not a cast can be successfully performed depends on the 
relationship of the classes involved in the class hierarchy.

</para>





<para id="p1097">
A reference to any object can be assigned to a reference variable of the type


<emphasis id="strong1117" effect="bold">
Object

</emphasis>
, because the 

<emphasis id="strong1118" effect="bold">
Object

</emphasis>
 class is a 
superclass of every other class.

</para>





<para id="p1098">
When we cast a reference along the class hierarchy in a direction away from 
the root class 

<emphasis id="strong1119" effect="bold">
Object

</emphasis>
 toward the leaves, we often refer to it 
as a 

<emphasis id="em1010" effect="italics">
downcast

</emphasis>
.

</para>





<para id="p1099">
Whether or not a method can be called on a reference to an object depends on 
the current type of the reference and the location in the class hierarchy where 
the method is defined. In order to use a reference of a class type to call a 
method, the method must be defined in or inherited into that class.

</para>




	

</section>
<section id="h11008">
<title>
<emphasis id="Miscellaneous" effect="bold">

Miscellaneous

</emphasis>


</title>


	

<para id="p1100">
This section contains a variety of miscellaneous information.

</para>





	

<note id="note1018" type="">


		


			


				

<emphasis id="strong1120" effect="bold">
Housekeeping material

</emphasis>

				

<list id="ul1018" list-type="bulleted">

					

<item id="li1075">
Module name: Xna0112-Type Conversion, Casting, and 
					Assignment Compatibility

</item>


					

<item id="li1076">
File: Xna0112.htm


</item>


					

<item id="li1077">
Published: 02/27/14

</item>


				

</list>


				

</note>

			


		



	





	

<note id="note1019" type="">


		


			


				

<emphasis id="strong1121" effect="bold">
Disclaimers:

</emphasis>
<para id="p1101">
<emphasis id="strong1122" effect="bold">
Financial

</emphasis>
: Although the Connexions
site makes it possible for you to download a PDF file for this
module at no charge, and also makes it possible for you to
purchase a pre-printed version of the PDF file, you should be
aware that some of the HTML elements in this module may not translate well into
PDF.

</para>



				

<para id="p1102">
I also want you to know that, I receive no financial compensation from the Connexions website even if you purchase 
	the PDF version of the module.

</para>



				

<para id="p1103">
In the past, unknown individuals have copied my modules from cnx.org, converted them to Kindle books, and 
				placed them for sale on Amazon.com showing me as the author. I 
				neither receive compensation for those sales nor do I know who does 
				receive compensation. If you purchase such a book, please be 
				aware that it is a copy of a module that is freely 
				available on cnx.org and that it was made and published without 
				my prior knowledge.

</para>



				

<para id="p1104">
<emphasis id="strong1123" effect="bold">
Affiliation

</emphasis>
: I am a professor of Computer Information 
	Technology at Austin Community College in Austin, TX.
	

</para>



				

</note>

			


		



	






</section>
<section id="h11009">
<title>
<emphasis id="Complete_program_listing" effect="bold">

Complete program listing

</emphasis>


</title>




<para id="p1105">
A complete listing of the C# program discussed in this module is provided in 

<link id="a1083" target-id="Listing_11">

Listing 11

</link>

. 

</para>



	

	


<note id="note1020" type="">


<para id="p1106">
<emphasis id="Listing_11" effect="bold">

Listing 11

</emphasis>

. Project Polymorph02.

</para>



				

<code id="pre1013" display="block">/*Project Polymorph02
Copyright 2002, R.G.Baldwin

This program illustrates downcasting
Program output is:
m in class B
*********************************************************/
using System;

class A {
  //this class is empty
}//end class A
//======================================================//

class B : A {
  public void m() {
    Console.WriteLine("m in class B");
  }//end method m()
}//end class B
//======================================================//

class C {
  //this class is empty
}//end class C
//======================================================//

public class Polymorph02 {
  public static void Main() {
    Object var = new B();
    //Following will not compile
    //var.m();
    //Following will not compile
    //((A)var).m();    
    //Following will compile and run
    ((B)var).m();

    //Following will compile and run
    B v1 = (B)var;
    //Following will not execute.
    // Causes a runtime exception.
    //C v2 = (C)var;
    //Following will not compile
    //C v3 = (B)var;

    //Pause until user presses any key.
    Console.ReadKey();
  }//end Main
}//end class Polymorph02
//======================================================/
</code>



				

</note>

			


		



	




	

<para id="p1107">
-end- 

</para>







</section>
</content>




</document>