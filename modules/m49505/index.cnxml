<document xmlns="http://cnx.rice.edu/cnxml"> 
<title>Xna0110-Polymorphism Based on Overloaded Methods</title>
<metadata xmlns:md="http://cnx.rice.edu/mdml">
  <md:content-id>m49505</md:content-id>
  <md:title>Xna0110-Polymorphism Based on Overloaded Methods</md:title>
  <md:abstract>Learn that overloaded methods have the same name and different formal argument lists; that the word polymorphism means something like one name, many forms; that polymorphism manifests itself in C# in the form of multiple methods having the same name; that polymorphism manifests itself in three distinct forms in C#: method overloading, method overriding through class inheritance, and method overriding through interface inheritance.</md:abstract>
  <md:uuid>26f11984-0556-46b0-bff6-9758ffc05789</md:uuid>
</metadata>

<content>






<para id="p1000">
Revised: Thu May 05 15:30:44 CDT 2016

</para>




<para id="p1001">
<emphasis id="em1000" effect="italics">
This page is part of a Book titled 


<link id="a1000" url="http://cnx.org/contents/GY804-eY">

XNA Game Studio 

</link>

.

</emphasis>
</para>











<section id="h11000">
<title>
<emphasis id="Table_of_Contents" effect="bold">

Table of Contents

</emphasis>


</title>




<list id="ul1000" list-type="bulleted">
<item id="li1000">
<link id="a1001" target-id="Table_of_Contents">

Table of Contents

</link>




</item>


<item id="li1001">
<link id="a1002" target-id="Preface">

Preface

</link>




<list id="ul1001" list-type="bulleted">
<item id="li1002">
<link id="a1003" target-id="The_three_main_characteristics_of_an_objectOriented_program">

The three main characteristics of an object-oriented program

</link>




</item>


<item id="li1003">
<link id="a1004" target-id="Viewing_tip">

Viewing tip

</link>




<list id="ul1002" list-type="bulleted">
<item id="li1004">
<link id="a1005" target-id="Figures">

Figures

</link>




</item>


<item id="li1005">
<link id="a1006" target-id="Listings">

Listings

</link>




</item>


</list>


</item>


</list>


</item>


<item id="li1006">
<link id="a1007" target-id="General_background_information">

General 
	background information

</link>




<list id="ul1003" list-type="bulleted">
<item id="li1007">
<link id="a1008" target-id="What_is_polymorphism">

What is polymorphism?

</link>




</item>


<item id="li1008">
<link id="a1009" target-id="How_does_C_implement_polymorphism">

How does C# implement polymorphism?

</link>




</item>


<item id="li1009">
<link id="a1010" target-id="The_class_named_Object">

The class named Object

</link>




</item>


<item id="li1010">
<link id="a1011" target-id="Multiple_methods_with_the_same_name">

Multiple methods with the same name

</link>




</item>


<item id="li1011">
<link id="a1012" target-id="CompileTime_and_runtime_polymorphism_whats_the_difference">

Compile-time and runtime polymorphism, what's the difference?

</link>




</item>


<item id="li1012">
<link id="a1013" target-id="Every_class_extends_some_other_class">

Every class extends some other class

</link>




</item>


<item id="li1013">
<link id="a1014" target-id="A_class_hierarchy">

A class hierarchy

</link>




</item>


<item id="li1014">
<link id="a1015" target-id="Methods_in_the_Object_class">

Methods in the Object class

</link>




<list id="ul1004" list-type="bulleted">
<item id="li1015">
<link id="a1016" target-id="Some_methods_are_overloaded">

Some methods are overloaded

</link>




</item>


<item id="li1016">
<link id="a1017" target-id="Some_methods_are_meant_to_be_overridden">

Some methods are meant to be overridden

</link>




</item>


<item id="li1017">
<link id="a1018" target-id="Some_methods_are_meant_to_be_used_as_is">

Some methods are meant to be used as is

</link>




</item>


</list>


</item>


<item id="li1018">
<link id="a1019" target-id="Three_distinct_forms_of_polymorphism">

Three distinct forms of polymorphism

</link>




</item>


<item id="li1019">
<link id="a1020" target-id="Method_overloading">

Method overloading

</link>




<list id="ul1005" list-type="bulleted">
<item id="li1020">
<link id="a1021" target-id="Duplicate_method_names">

Duplicate method names

</link>




</item>


<item id="li1021">
<link id="a1022" target-id="CompileTime_polymorphism">

Compile-time polymorphism

</link>




</item>


<item id="li1022">
<link id="a1023" target-id="Selection_based_on_the_argument_list">

Selection based on the argument list

</link>




</item>


</list>


</item>


</list>


</item>


<item id="li1023">
<link id="a1024" target-id="Preview">

Preview

</link>




<list id="ul1006" list-type="bulleted">
<item id="li1024">
<link id="a1025" target-id="Keeping_it_short_and_simple">

Keeping it short and simple

</link>




</item>


<item id="li1025">
<link id="a1026" target-id="A_sample_program">

A sample program

</link>




<list id="ul1007" list-type="bulleted">
<item id="li1026">
<link id="a1027" target-id="Within_the_class_and_the_hierarchy">

Within the class and the hierarchy

</link>




</item>


<item id="li1027">
<link id="a1028" target-id="Class_B_extends_class_A_which_extends_Object">

Class B extends class A, which extends Object

</link>




</item>


<item id="li1028">
<link id="a1029" target-id="Designed_to_illustrate_method_overloading">

Designed to illustrate method overloading

</link>




</item>


</list>


</item>


</list>


</item>


<item id="li1029">
<link id="a1030" target-id="Discussion_and_sample_code">

Discussion and sample code

</link>




<list id="ul1008" list-type="bulleted">
<item id="li1030">
<link id="a1031" target-id="Will_discuss_in_fragments">

Will discuss in fragments

</link>




</item>


<item id="li1031">
<link id="a1032" target-id="The_class_named_A">

The class named A

</link>




<list id="ul1009" list-type="bulleted">
<item id="li1032">
<link id="a1033" target-id="Redundant_code">

Redundant code

</link>




</item>


<item id="li1033">
<link id="a1034" target-id="The_method_named_m">

The method named m()

</link>




</item>


</list>


</item>


<item id="li1034">
<link id="a1035" target-id="The_class_named_B">

The class named B

</link>




<list id="ul1010" list-type="bulleted">
<item id="li1035">
<link id="a1036" target-id="Overloaded_methods">

Overloaded methods

</link>




</item>


</list>


</item>


<item id="li1036">
<link id="a1037" target-id="The_driver_class">

The driver class

</link>




<list id="ul1011" list-type="bulleted">
<item id="li1037">
<link id="a1038" target-id="Call_all_three_overloaded_methods">

Call all three overloaded methods

</link>




</item>


<item id="li1038">
<link id="a1039" target-id="One_version_is_inherited">

One version is inherited

</link>




</item>


<item id="li1039">
<link id="a1040" target-id="Two_versions_defined_in_class_B">

Two versions defined in class B

</link>




</item>


</list>


</item>


<item id="li1040">
<link id="a1041" target-id="The_output">

The output

</link>




<list id="ul1012" list-type="bulleted">
<item id="li1041">
<link id="a1042" target-id="Parameters_are_not_displayed">

Parameters are not displayed

</link>




</item>


</list>


</item>


</list>


</item>


<item id="li1042">
<link id="a1043" target-id="Run_the_program">

Run the program

</link>




</item>


<item id="li1043">
<link id="a1044" target-id="Run_my_program">

Run my program

</link>




</item>


<item id="li1044">
<link id="a1045" target-id="Summary">

Summary

</link>




</item>


<item id="li1045">
<link id="a1046" target-id="Miscellaneous">

Miscellaneous

</link>




</item>


<item id="li1046">
<link id="a1047" target-id="Complete_program_listing">

Complete program listing

</link>




</item>


</list>




	

</section>
<section id="h11001">
<title>
<emphasis id="Preface" effect="bold">

Preface

</emphasis>


</title>


	
	

<para id="p1002">
This module is one in a collection of modules designed primarily for 
	teaching 

<emphasis id="strong1000" effect="bold">
GAME 1343 Game and Simulation Programming I

</emphasis>
 at 
	Austin Community College in Austin, TX. These modules are intended to 
	supplement and not to replace the textbook.

</para>





<para id="p1003">
An earlier module titled 


<link id="a1048" url="http://cnx.org/contents/GY804-eY:g-5oRzQu">

Getting Started

</link>

 provided information on how 
to get started programming with Microsoft's XNA Game Studio. 

</para>





<section id="h21000">
<title>
<emphasis id="The_three_main_characteristics_of_an_objectOriented_program" effect="bold">

The three main characteristics of an object-oriented program

</emphasis>


</title>




<para id="p1004">
Object-oriented programs exhibit three main characteristics:

</para>





<list id="ul1013" list-type="bulleted">

	

<item id="li1047">
Encapsulation

</item>


	

<item id="li1048">
Inheritance

</item>


	

<item id="li1049">
Polymorphism

</item>




</list>




<para id="p1005">
I have explained encapsulation and inheritance in previous modules. I will 
begin the explanation of polymorphism in this module. However, polymorphism is a 
complex topic and several modules will be required to complete the explanation.

</para>



	

</section>
<section id="h21001">
<title>
<emphasis id="Viewing_tip" effect="bold">

Viewing tip

</emphasis>


</title>


	

<para id="p1006">
I recommend that you open another copy of this module in a separate 
browser window and use the following links to easily find and view the Figures 
and Listings while you are reading about them.

</para>



	

<section id="h31000">
<title>
<emphasis id="Figures" effect="bold">

Figures

</emphasis>


</title>


	

<list id="ul1014" list-type="bulleted">

		

<item id="li1050">
<link id="a1049" target-id="Figure_1">

Figure 1

</link>

. Screen output from the project named Polymorph01.

</item>



	

</list>


	

</section>
<section id="h31001">
<title>
<emphasis id="Listings" effect="bold">

Listings

</emphasis>


</title>


	

<list id="ul1015" list-type="bulleted">

		

<item id="li1051">
<link id="a1050" target-id="Listing_1">

Listing 1

</link>

. Class A from the project named Polymorph01.

</item>


		

<item id="li1052">
<link id="a1051" target-id="Listing_2">

Listing 2

</link>

. Class B from the project named Polymorph01.

</item>


		

<item id="li1053">
<link id="a1052" target-id="Listing_3">

Listing 3

</link>

. Class Polymorph01 from the project named Polymorph01.

</item>


		

<item id="li1054">
<link id="a1053" target-id="Listing_4">

Listing 4

</link>

. Project Polymorph01.

</item>


	

</list>


	

</section>
</section>
</section>
<section id="h11002">
<title>
<emphasis id="General_background_information" effect="bold">

General 
	background information

</emphasis>


</title>




<section id="h21002">
<title>
<emphasis id="What_is_polymorphism" effect="bold">

What is polymorphism?

</emphasis>


</title>




<para id="p1007">
The meaning of the word polymorphism is something like 

<emphasis id="em1001" effect="italics">
one name, many 
forms

</emphasis>
.

</para>





</section>
<section id="h21003">
<title>
<emphasis id="How_does_C_implement_polymorphism" effect="bold">

How does C# implement polymorphism?

</emphasis>


</title>




<para id="p1008">
Polymorphism manifests itself in C# in the form of multiple methods having 
the same name.

</para>





<para id="p1009">
In some cases, multiple methods have the same name, but have different formal 
argument lists. These are 

<emphasis id="em1002" effect="italics">
overloaded

</emphasis>
 methods.

</para>





<para id="p1010">
In other cases, multiple methods have the same name, same return type, and 
same formal argument list. These are 

<emphasis id="em1003" effect="italics">
overridden

</emphasis>
 methods.

</para>





<para id="p1011">
This module concentrates on the use of method 

<emphasis id="em1004" effect="italics">
overloading

</emphasis>
 to achieve


<emphasis id="em1005" effect="italics">
compile-time

</emphasis>
 polymorphism.

</para>





</section>
<section id="h21004">
<title>
<emphasis id="The_class_named_Object" effect="bold">

The class named Object

</emphasis>


</title>




<para id="p1012">
As you learned in an earlier module, every class in C# is a direct or 
indirect subclass of the class named 

<emphasis id="strong1001" effect="bold">
Object

</emphasis>
. Methods defined in 
the 

<emphasis id="strong1002" effect="bold">
Object

</emphasis>
 class are inherited into all other classes. Some of 
those inherited methods may be 

<emphasis id="em1006" effect="italics">
overridden

</emphasis>
 to make their behavior more 
appropriate for objects instantiated from the new subclasses. However, this 
module is not about 

<emphasis id="strong1003" effect="bold">
<emphasis id="em1007" effect="italics">
overriding

</emphasis>
</emphasis>
 methods. Instead it is about 


<emphasis id="strong1004" effect="bold">
<emphasis id="em1008" effect="italics">
overloading

</emphasis>
</emphasis>
 methods. 
I will cover method overriding in future modules.

</para>





</section>
<section id="h21005">
<title>
<emphasis id="Multiple_methods_with_the_same_name" effect="bold">

Multiple methods with the same name

</emphasis>


</title>




<para id="p1013">
<emphasis id="strong1005" effect="bold">
<emphasis id="em1009" effect="italics">
Overloaded

</emphasis>
</emphasis>
 methods have the same name and different formal argument lists. 
They may or may not have the same return type.

</para>





<para id="p1014">
Polymorphism manifests itself in C# in the form of multiple methods having 
the same name. As mentioned above, this module concentrates on method 

<emphasis id="em1010" effect="italics">

overloading

</emphasis>
, sometimes referred to as 

<emphasis id="em1011" effect="italics">
compile-time polymorphism

</emphasis>
. 
Subsequent modules concentrate on method 

<emphasis id="em1012" effect="italics">
overriding

</emphasis>
, sometimes referred 
to as 

<emphasis id="em1013" effect="italics">
runtime polymorphism

</emphasis>
.

</para>





</section>
<section id="h21006">
<title>
<emphasis id="CompileTime_and_runtime_polymorphism_whats_the_difference" effect="bold">

Compile-time and runtime polymorphism, what's the difference?

</emphasis>


</title>




<para id="p1015">
During the compilation and execution of polymorphic code, the compiler and 
the runtime system must decide which of two or more methods having the same name 
in the same scope must be executed. With method overloading, that decision is 
made when the program is compiled. With method overriding, that decision is 
deferred and made at runtime. Hence we have the terms 

<emphasis id="em1014" effect="italics">
compile-time 
polymorphism

</emphasis>
 and 

<emphasis id="em1015" effect="italics">
runtime polymorphism

</emphasis>
.

</para>





</section>
<section id="h21007">
<title>
<emphasis id="Every_class_extends_some_other_class" effect="bold">

Every class extends some other class

</emphasis>


</title>




<para id="p1016">
Every class in C# (except for the class named 

<emphasis id="strong1006" effect="bold">
Object

</emphasis>
) 
extends some other class. If you don't explicitly specify the class that your 
new class extends, it will automatically extend the class named 

<emphasis id="strong1007" effect="bold">
Object

</emphasis>
.

</para>





</section>
<section id="h21008">
<title>
<emphasis id="A_class_hierarchy" effect="bold">

A class hierarchy

</emphasis>


</title>




<para id="p1017">
Thus, all classes in C# exist in a class hierarchy where the class named


<emphasis id="strong1008" effect="bold">
Object

</emphasis>
 forms the root of the hierarchy.

</para>





<para id="p1018">
Some classes extend 

<emphasis id="strong1009" effect="bold">
Object

</emphasis>
 directly, while other classes are 
subclasses of 

<emphasis id="strong1010" effect="bold">
Object

</emphasis>
 further down the hierarchy (they extend 
classes that extend classes that extend 

<emphasis id="strong1011" effect="bold">
Object

</emphasis>
).

</para>





</section>
<section id="h21009">
<title>
<emphasis id="Methods_in_the_Object_class" effect="bold">

Methods in the Object class

</emphasis>


</title>




<para id="p1019">
You learned in an earlier module that the class named 

<emphasis id="strong1012" effect="bold">
Object

</emphasis>
 
defines default versions of the following methods and that every class in the 
hierarchy inherits them:

</para>





<list id="ul1016" list-type="bulleted">

	

<item id="li1055">
<emphasis id="strong1013" effect="bold">
Equals

</emphasis>
 - Overloaded. Determines whether two Object 
	instances are equal.
	

<list id="ul1017" list-type="bulleted">

		

<item id="li1056">
<emphasis id="strong1014" effect="bold">
Equals(Object)

</emphasis>
 - Determines whether the specified 
		Object is equal to the current Object.

</item>


		

<item id="li1057">
<emphasis id="strong1015" effect="bold">
Equals(Object,Object)

</emphasis>
 - Determines whether the 
		specified Object instances are considered equal.

</item>


	

</list>


	

</item>


	

<item id="li1058">
<emphasis id="strong1016" effect="bold">
Finalize

</emphasis>
 - Allows an Object to attempt to free 
	resources and perform other cleanup operations before the Object is 
	reclaimed by garbage collection.

</item>


	

<item id="li1059">
<emphasis id="strong1017" effect="bold">
GetHashCode

</emphasis>
 - Serves as a hash function for a 
	particular type. 

</item>


	

<item id="li1060">
<emphasis id="strong1018" effect="bold">
GetType

</emphasis>
 - Gets the Type of the current instance.

</item>


	

<item id="li1061">
<emphasis id="strong1019" effect="bold">
MemberwiseClone

</emphasis>
 - Creates a shallow copy of the current 
	Object.

</item>


	

<item id="li1062">
<emphasis id="strong1020" effect="bold">
ReferenceEquals

</emphasis>
 - Determines whether the specified 
	Object instances are the same instance.

</item>


	

<item id="li1063">
<emphasis id="strong1021" effect="bold">
ToString

</emphasis>
 - Returns a String that represents the current 
	Object.

</item>




</list>




<section id="h31002">
<title>
<emphasis id="Some_methods_are_overloaded" effect="bold">

Some methods are overloaded

</emphasis>


</title>




<para id="p1020">
The two methods named 

<emphasis id="strong1022" effect="bold">
Equals

</emphasis>
 are defined as overloaded 
methods in the 

<emphasis id="strong1023" effect="bold">
Object

</emphasis>
 class. (They have the same name and 
different formal argument lists.)

</para>





</section>
<section id="h31003">
<title>
<emphasis id="Some_methods_are_meant_to_be_overridden" effect="bold">

Some methods are meant to be overridden

</emphasis>


</title>




<para id="p1021">
Some of these methods are intended to be overridden for various purposes. 
This includes 

<emphasis id="strong1024" effect="bold">
GetHashCode

</emphasis>
, and 

<emphasis id="strong1025" effect="bold">
ToString

</emphasis>
.

</para>





</section>
<section id="h31004">
<title>
<emphasis id="Some_methods_are_meant_to_be_used_as_is" effect="bold">

Some methods are meant to be used as is

</emphasis>


</title>




<para id="p1022">
However, some of the methods, such as 

<emphasis id="strong1026" effect="bold">
GetType

</emphasis>
 are intended 
to be used as is without overriding.

</para>





</section>
</section>
<section id="h21010">
<title>
<emphasis id="Three_distinct_forms_of_polymorphism" effect="bold">

Three distinct forms of polymorphism

</emphasis>


</title>




<para id="p1023">
From a practical programming viewpoint, polymorphism manifests itself in 
three distinct forms in C#:

</para>





<list id="ul1018" list-type="bulleted">

	

<item id="li1064">
Method overloading

</item>


	

<item id="li1065">
Method overriding through class inheritance

</item>


	

<item id="li1066">
Method overriding through interface inheritance

</item>




</list>




</section>
<section id="h21011">
<title>
<emphasis id="Method_overloading" effect="bold">

Method overloading

</emphasis>


</title>




<para id="p1024">
I will begin the discussion of polymorphism with method overloading, which is 
the simplest of the three. I will cover method overloading in this module and 
will cover polymorphism based on overridden methods using class inheritance and 
interface inheritance in future modules.

</para>





<section id="h31005">
<title>
<emphasis id="Duplicate_method_names" effect="bold">

Duplicate method names

</emphasis>


</title>




<para id="p1025">
C# allows you to have two or more method definitions in the same scope with 
the same name, provided that they have different formal argument lists. This is 
method 

<emphasis id="em1016" effect="italics">
overloading

</emphasis>
.

</para>





</section>
<section id="h31006">
<title>
<emphasis id="CompileTime_polymorphism" effect="bold">

Compile-time polymorphism

</emphasis>


</title>




<para id="p1026">
Some authors refer to method overloading as a form of 

<emphasis id="em1017" effect="italics">
compile-time 
polymorphism

</emphasis>
, as distinguished from 

<emphasis id="em1018" effect="italics">
run-time polymorphism

</emphasis>
. This distinction 
comes from the fact that, for each method call, the compiler determines which 
method (from a group of overloaded methods) will be executed. This decision is 
made when the program is compiled.

</para>





<para id="p1027">
In contrast, with method overriding, the determination of which overridden 
method to execute isn't made until runtime.

</para>





</section>
<section id="h31007">
<title>
<emphasis id="Selection_based_on_the_argument_list" effect="bold">

Selection based on the argument list

</emphasis>


</title>




<para id="p1028">
In practice, with overloaded methods, the compiler simply examines the types, 
number, and order of the parameters being passed in a method call and selects 
the overloaded method having a matching formal argument list. 

</para>




	

</section>
</section>
</section>
<section id="h11003">
<title>
<emphasis id="Preview" effect="bold">

Preview

</emphasis>


</title>


	

<section id="h21012">
<title>
<emphasis id="Keeping_it_short_and_simple" effect="bold">

Keeping it short and simple

</emphasis>


</title>




<para id="p1029">
In these modules on polymorphism, I will explain sample programs that are as 
short and as simple as I know how to make them, while still illustrating the 
important points regarding polymorphism. My objective is to make the polymorphic 
concepts as clear as possible without having those concepts clouded by other 
programming issues.

</para>





<para id="p1030">
Because of their simplicity, these programs aren't likely to resemble 
problems that you will encounter in the real world. I will simply ask you to 
trust me when I tell you that polymorphism has enormous application in real 
world programming. 

</para>





</section>
<section id="h21013">
<title>
<emphasis id="A_sample_program" effect="bold">

A sample program

</emphasis>


</title>




<para id="p1031">
I will explain a sample program named 

<emphasis id="strong1027" effect="bold">
Polymorph01

</emphasis>
 to 
illustrate method overloading. A complete listing of the program is provided in 


<link id="a1054" target-id="Listing_4">

Listing 4

</link>

 near the end of the module.

</para>





<section id="h31008">
<title>
<emphasis id="Within_the_class_and_the_hierarchy" effect="bold">

Within the class and the hierarchy

</emphasis>


</title>




<para id="p1032">
Method overloading can occur both within a class definition, and vertically 
within the class inheritance hierarchy.

</para>





<para id="p1033">
In other words, an overloaded method can be inherited into a class that 
defines other overloaded versions of the method.

</para>





<para id="p1034">
The program named 

<emphasis id="strong1028" effect="bold">
Polymorph01

</emphasis>
 illustrates both aspects of 
method overloading.

</para>





</section>
<section id="h31009">
<title>
<emphasis id="Class_B_extends_class_A_which_extends_Object" effect="bold">

Class B extends class A, which extends Object

</emphasis>


</title>




<para id="p1035">
Upon examination of the program, you will see that the class named 

<emphasis id="strong1029" effect="bold">
A

</emphasis>
 
extends the class named 

<emphasis id="strong1030" effect="bold">
Object

</emphasis>
. You will also see that the 
class named 

<emphasis id="strong1031" effect="bold">
B

</emphasis>
 extends the class named 

<emphasis id="strong1032" effect="bold">
A

</emphasis>
.

</para>





<para id="p1036">
The class named 

<emphasis id="strong1033" effect="bold">
Polymorph01

</emphasis>
 is a driver class whose 

<emphasis id="strong1034" effect="bold">

Main

</emphasis>
 method exercises the methods defined in the classes named 

<emphasis id="strong1035" effect="bold">

A

</emphasis>
 and 

<emphasis id="strong1036" effect="bold">
B

</emphasis>
.

</para>





</section>
<section id="h31010">
<title>
<emphasis id="Designed_to_illustrate_method_overloading" effect="bold">

Designed to illustrate method overloading

</emphasis>


</title>




<para id="p1037">
Once again, this program is not intended to correspond to any particular 
real-world scenario. Rather, it is a very simple program designed specifically 
to illustrate method overloading. 

</para>





	

</section>
</section>
</section>
<section id="h11004">
<title>
<emphasis id="Discussion_and_sample_code" effect="bold">

Discussion and sample code

</emphasis>


</title>


	
	

<section id="h21014">
<title>
<emphasis id="Will_discuss_in_fragments" effect="bold">

Will discuss in fragments

</emphasis>


</title>




<para id="p1038">
As usual, I will discuss this program in fragments. A complete listing is 
provided in 

<link id="a1055" target-id="Listing_4">

Listing 4

</link>

 near the end of the module.

</para>





</section>
<section id="h21015">
<title>
<emphasis id="The_class_named_A" effect="bold">

The class named A

</emphasis>


</title>




<para id="p1039">
The code in 

<link id="a1056" target-id="Listing_1">

Listing 1

</link>

 defines the class named 

<emphasis id="strong1037" effect="bold">
A

</emphasis>
, which 
explicitly extends 

<emphasis id="strong1038" effect="bold">
Object

</emphasis>
. 

</para>



	




<note id="note1000" type="">


<para id="p1040">
<emphasis id="Listing_1" effect="bold">

Listing 1

</emphasis>

. Class A from the project named Polymorph01.

</para>



				

<code id="pre1000" display="block">using System;

class A : Object {
  public void m() {
    Console.WriteLine("m()");
  }//end method m()
}//end class A
</code>



				

</note>

			


		



	




	

<section id="h31011">
<title>
<emphasis id="Redundant_code" effect="bold">

Redundant code

</emphasis>


</title>




<para id="p1041">
Recall that explicitly extending 

<emphasis id="strong1039" effect="bold">
Object

</emphasis>
 is not required (but 
it also doesn't hurt anything).

</para>





<para id="p1042">
The class named 

<emphasis id="strong1040" effect="bold">
A

</emphasis>
 would extend the class named 

<emphasis id="strong1041" effect="bold">

Object

</emphasis>
 by default unless the class named 

<emphasis id="strong1042" effect="bold">
A

</emphasis>
 explicitly 
extends some other class.

</para>





</section>
<section id="h31012">
<title>
<emphasis id="The_method_named_m" effect="bold">

The method named m()

</emphasis>


</title>




<para id="p1043">
The code in 

<link id="a1057" target-id="Listing_1">

Listing 1

</link>

 defines a method named 

<emphasis id="strong1043" effect="bold">
m()

</emphasis>
. Note that 
this version of the method has an empty argument list (it doesn't receive any 
parameters when it is executed). The behavior of the method is simply to display 
a message indicating that it is executing.

</para>





</section>
</section>
<section id="h21016">
<title>
<emphasis id="The_class_named_B" effect="bold">

The class named B

</emphasis>


</title>




<para id="p1044">
<link id="a1058" target-id="Listing_2">

Listing 2

</link>

 contains the definition for the class named 

<emphasis id="strong1044" effect="bold">
B

</emphasis>
. 
This class extends the class named 

<emphasis id="strong1045" effect="bold">
A

</emphasis>
 and inherits the method 
named 

<emphasis id="strong1046" effect="bold">
m

</emphasis>
 defined in the class named 

<emphasis id="strong1047" effect="bold">
A

</emphasis>
. 

</para>





<note id="note1001" type="">


<para id="p1045">
<emphasis id="Listing_2" effect="bold">

Listing 2

</emphasis>

. Class B from the project named Polymorph01.

</para>



				

<code id="pre1001" display="block">class B : A {
  public void m(int x) {
    Console.WriteLine("m(int x)");
  }//end method m(int x)
  //---------------------------------//

  public void m(String y) {
    Console.WriteLine("m(String y)");
  }//end method m(String y)
}//end class B
</code>



				

</note>

			


		



	




	

<section id="h31013">
<title>
<emphasis id="Overloaded_methods" effect="bold">

Overloaded methods

</emphasis>


</title>




<para id="p1046">
In addition to the inherited method named 

<emphasis id="strong1048" effect="bold">
m

</emphasis>
, the class named


<emphasis id="strong1049" effect="bold">
B

</emphasis>
 defines two additional overloaded versions of the method 
named 

<emphasis id="strong1050" effect="bold">
m

</emphasis>
:

</para>





<list id="ul1019" list-type="bulleted">

	

<item id="li1067">
m(int x)

</item>


	

<item id="li1068">
m(String y)

</item>




</list>




<para id="p1047">
Note that each of these versions of the method receives a single parameter 
and the type of the parameter is different in each case.

</para>





<para id="p1048">
As with the version of the method having the same name defined in the class 
named 

<emphasis id="strong1051" effect="bold">
A

</emphasis>
, the behavior of each of these two methods is simply to 
display a message indicating that it is executing.

</para>





</section>
</section>
<section id="h21017">
<title>
<emphasis id="The_driver_class" effect="bold">

The driver class

</emphasis>


</title>




<para id="p1049">
<link id="a1059" target-id="Listing_3">

Listing 3

</link>

 contains the definition of the driver class named 

<emphasis id="strong1052" effect="bold">

Polymorph01

</emphasis>
. 

</para>





<note id="note1002" type="">


<para id="p1050">
<emphasis id="Listing_3" effect="bold">

Listing 3

</emphasis>

. Class Polymorph01 from the project named Polymorph01.

</para>



				

<code id="pre1002" display="block">public class Polymorph01 {
  public static void Main() {
    B var = new B();
    var.m();
    var.m(3);
    var.m("String");

    //Pause until the user presses a key.
    Console.ReadKey();
  }//end Main

}//end class Polymorph01
</code>



				

</note>

			


		



	




	

<section id="h31014">
<title>
<emphasis id="Call_all_three_overloaded_methods" effect="bold">

Call all three overloaded methods

</emphasis>


</title>




<para id="p1051">
The code in the 

<emphasis id="strong1053" effect="bold">
Main

</emphasis>
 method

</para>





<list id="ul1020" list-type="bulleted">

	

<item id="li1069">
Instantiates a new object of the class named B

</item>


	

<item id="li1070">
Successively calls each of the three overloaded versions of the method 
	named 

<emphasis id="strong1054" effect="bold">
m

</emphasis>
 on the reference to that object.

</item>




</list>




</section>
<section id="h31015">
<title>
<emphasis id="One_version_is_inherited" effect="bold">

One version is inherited

</emphasis>


</title>




<para id="p1052">
The overloaded version of the method named 

<emphasis id="strong1055" effect="bold">
m

</emphasis>
, defined in the 
class named 

<emphasis id="strong1056" effect="bold">
A

</emphasis>
, is inherited into the class named 

<emphasis id="strong1057" effect="bold">
B

</emphasis>
. 
Hence, it can be called on a reference to an object instantiated from the class 
named 

<emphasis id="strong1058" effect="bold">
B

</emphasis>
.

</para>





</section>
<section id="h31016">
<title>
<emphasis id="Two_versions_defined_in_class_B" effect="bold">

Two versions defined in class B

</emphasis>


</title>




<para id="p1053">
The other two versions of the method named 

<emphasis id="strong1059" effect="bold">
m

</emphasis>
 are defined in 
the class named 

<emphasis id="strong1060" effect="bold">
B

</emphasis>
. Thus, they also can be called on a reference 
to an object instantiated from the class named 

<emphasis id="strong1061" effect="bold">
B

</emphasis>
.

</para>





</section>
</section>
<section id="h21018">
<title>
<emphasis id="The_output" effect="bold">

The output

</emphasis>


</title>




<para id="p1054">
As you would expect from the code that you examined for each of the three 
methods, the output produced by sending messages to the object asking it to 
execute each of the three overloaded versions of the methods named 

<emphasis id="strong1062" effect="bold">
m

</emphasis>
 
is shown in 

<link id="a1060" target-id="Figure_1">

Figure 1

</link>

.

</para>



	


<note id="note1003" type="">


<para id="p1055">
<emphasis id="Figure_1" effect="bold">

Figure 1

</emphasis>

. Screen output from the project named Polymorph01.

</para>



							

<code id="pre1003" display="block">m()
m(int x)
m(String y)
</code>


				

</note>

			


		



	




	

<section id="h31017">
<title>
<emphasis id="strong1063" effect="bold">
<emphasis id="Parameters_are_not_displayed" effect="bold">

Parameters are not displayed

</emphasis>


</emphasis>
</title>




<para id="p1056">
The values of the parameters passed to the methods do not appear in the 
output. In this program, the parameters are used solely to make it possible for 
the compiler to select the correct version of the overloaded method to execute 
in each case.

</para>





<note id="note1004" type="">


In a real program, however, the 
	parameters would normally be used by the code in the method for some useful 
	purpose.

</note>






<para id="p1057">
This output confirms that each overloaded version of the method was properly 
selected for execution based on the matching of method parameters to the formal 
argument list of each method. 

</para>







</section>
</section>
</section>
<section id="h11005">
<title>
<emphasis id="Run_the_program" effect="bold">

Run the program

</emphasis>


</title>





<para id="p1058">
I encourage you to copy the code from 

<link id="a1061" target-id="Listing_4">

Listing 4

</link>

. Use that code to create 
a C# console project. Compile and run the project. Experiment with the 
code, making changes, and observing the results of your changes. Make 
certain that you can explain why your changes behave as they do.

</para>





</section>
<section id="h11006">
<title>
<emphasis id="Run_my_program" effect="bold">

Run my program

</emphasis>


</title>




<para id="p1059">
Click 

<link id="a1062" url="Polymorph01.zip">

here

</link>

 to download a zip file containing my 
version of the program. Extract the folder named 

<emphasis id="strong1064" effect="bold">
Polymorph01

</emphasis>
 from the 
zip file and save it somewhere on your disk. Start 

<emphasis id="strong1065" effect="bold">
Visual C# 2010 
Express

</emphasis>
 and select 

<emphasis id="strong1066" effect="bold">
Open Project...

</emphasis>
 from the 

<emphasis id="strong1067" effect="bold">

File

</emphasis>
 menu. Navigate to the project folder and select the file with the 
extension of 

<emphasis id="strong1068" effect="bold">
.sln

</emphasis>
. This should cause the project to open and be 
ready to run or debug as described in the earlier module titled 


<link id="a1063" url="http://cnx.org/contents/GY804-eY:g-5oRzQu">

Getting Started

</link>

.

</para>



	

</section>
<section id="h11007">
<title>
<emphasis id="Summary" effect="bold">

Summary

</emphasis>


</title>




<para id="p1060">
Overloaded methods have the same name and different formal argument lists. 
They may or may not have the same return type.

</para>





<para id="p1061">
The word polymorphism means something like 

<emphasis id="em1019" effect="italics">
one name, many forms

</emphasis>
. 
Polymorphism manifests itself in C# in the form of multiple methods having the 
same name.

</para>





<para id="p1062">
Polymorphism manifests itself in three distinct forms in C#:

</para>





<list id="ul1021" list-type="bulleted">

	

<item id="li1071">
Method overloading

</item>


	

<item id="li1072">
Method overriding through class inheritance

</item>


	

<item id="li1073">
Method overriding through interface inheritance

</item>




</list>




<para id="p1063">
This module concentrates on method overloading, sometimes referred to as 

<emphasis id="em1020" effect="italics">

compile-time polymorphism

</emphasis>
.

</para>



	

</section>
<section id="h11008">
<title>
<emphasis id="Miscellaneous" effect="bold">

Miscellaneous

</emphasis>


</title>


	

<para id="p1064">
This section contains a variety of miscellaneous information.

</para>





	

<note id="note1005" type="">


		


			


				

<emphasis id="strong1069" effect="bold">
Housekeeping material

</emphasis>

				

<list id="ul1022" list-type="bulleted">

					

<item id="li1074">
Module name: Xna0110-Polymorphism Based on Overloaded 
					Methods

</item>


					

<item id="li1075">
File: Xna0110.htm


</item>


					

<item id="li1076">
Published: 02/27/14

</item>


				

</list>


				

</note>

			


		



	





	

<note id="note1006" type="">


		


			


				

<emphasis id="strong1070" effect="bold">
Disclaimers:

</emphasis>
<para id="p1065">
<emphasis id="strong1071" effect="bold">
Financial

</emphasis>
: Although the Connexions
site makes it possible for you to download a PDF file for this
module at no charge, and also makes it possible for you to
purchase a pre-printed version of the PDF file, you should be
aware that some of the HTML elements in this module may not translate well into
PDF.

</para>



				

<para id="p1066">
I also want you to know that, I receive no financial compensation from the Connexions website even if you purchase 
	the PDF version of the module.

</para>



				

<para id="p1067">
In the past, unknown individuals have copied my modules from cnx.org, converted them to Kindle books, and 
				placed them for sale on Amazon.com showing me as the author. I 
				neither receive compensation for those sales nor do I know who does 
				receive compensation. If you purchase such a book, please be 
				aware that it is a copy of a module that is freely 
				available on cnx.org and that it was made and published without 
				my prior knowledge.

</para>



				

<para id="p1068">
<emphasis id="strong1072" effect="bold">
Affiliation

</emphasis>
: I am a professor of Computer Information 
	Technology at Austin Community College in Austin, TX.
	

</para>



				

</note>

			


		



	






</section>
<section id="h11009">
<title>
<emphasis id="Complete_program_listing" effect="bold">

Complete program listing

</emphasis>


</title>




<para id="p1069">
A complete listing of the C# program discussed in this module is provided in 


<link id="a1064" target-id="Listing_4">

Listing 4

</link>

. 

</para>





<note id="note1007" type="">


<para id="p1070">
<emphasis id="Listing_4" effect="bold">

Listing 4

</emphasis>

. Project Polymorph01.

</para>



				

<code id="pre1004" display="block">/*Project Polymorph01
Copyright 2009, R.G.Baldwin

This program illustrates method
overloading, both within a class, and
up the inheritance hierarchy.

Program output is:
  
m()
m(int x)
m(String y)
**************************************/
using System;

class A : Object {
  public void m() {
    Console.WriteLine("m()");
  }//end method m()
}//end class A
//===================================//

class B : A {
  public void m(int x) {
    Console.WriteLine("m(int x)");
  }//end method m(int x)
  //---------------------------------//

  public void m(String y) {
    Console.WriteLine("m(String y)");
  }//end method m(String y)
}//end class B
//===================================//

public class Polymorph01 {
  public static void Main() {
    B var = new B();
    var.m();
    var.m(3);
    var.m("String");

    //Pause until the user presses
    // a key.
    Console.ReadKey();
  }//end Main

}//end class Polymorph01
</code>



				

</note>

			


		



	





<para id="p1071">
-end- 

</para>







</section>
</content>




</document>